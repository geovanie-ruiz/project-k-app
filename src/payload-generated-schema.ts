/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:db-schema` to regenerate this file.
 */

import {
  pgTable,
  index,
  uniqueIndex,
  foreignKey,
  serial,
  varchar,
  integer,
  timestamp,
  jsonb,
  boolean,
  numeric,
  pgEnum,
} from '@payloadcms/db-postgres/drizzle/pg-core';
import { sql, relations } from '@payloadcms/db-postgres/drizzle';
export const enum_articles_status = pgEnum('enum_articles_status', [
  'draft',
  'published',
]);
export const enum__articles_v_version_status = pgEnum(
  'enum__articles_v_version_status',
  ['draft', 'published']
);
export const enum_cards_recycle_rune = pgEnum('enum_cards_recycle_rune', [
  'Any',
  'Calm',
  'Chaos',
  'Fury',
  'Mental',
  'Order',
  'Physical',
]);
export const enum_cards_rune = pgEnum('enum_cards_rune', [
  'Calm',
  'Chaos',
  'Fury',
  'Mental',
  'Order',
  'Physical',
]);
export const enum_cards_type = pgEnum('enum_cards_type', [
  'Unit',
  'Champion',
  'Legend',
  'Spell',
  'Battlefield',
  'Gear',
  'Rune',
]);
export const enum_cards_rarity = pgEnum('enum_cards_rarity', [
  'None',
  'White Circle',
  'Green Triangle',
  'Purple Diamond',
  'Golden Pentagon',
  'Promo',
]);
export const enum_keywords_type = pgEnum('enum_keywords_type', [
  'Effect',
  'Timing',
  'Trigger',
]);
export const enum_keywords_position = pgEnum('enum_keywords_position', [
  'prefix',
  'suffix',
]);
export const enum_keywords_color = pgEnum('enum_keywords_color', [
  '#699667',
  '#835b86',
  '#a74e56',
  '#566f94',
  '#ab972c',
  '#ba7152',
  '#536878',
  '#8F7236',
]);
export const enum_spoilers_rune = pgEnum('enum_spoilers_rune', [
  'Calm',
  'Chaos',
  'Fury',
  'Mental',
  'Order',
  'Physical',
]);
export const enum_spoilers_recycle_rune = pgEnum('enum_spoilers_recycle_rune', [
  'Any',
  'Calm',
  'Chaos',
  'Fury',
  'Mental',
  'Order',
  'Physical',
]);
export const enum_spoilers_type = pgEnum('enum_spoilers_type', [
  'Unit',
  'Champion',
  'Legend',
  'Spell',
  'Battlefield',
  'Gear',
  'Rune',
]);
export const enum_spoilers_rarity = pgEnum('enum_spoilers_rarity', [
  'White Circle',
  'Green Triangle',
  'Purple Diamond',
  'Golden Pentagon',
]);
export const enum_users_links_site = pgEnum('enum_users_links_site', [
  'Blog',
  'Discord',
  'Instagram',
  'Mobalytics',
  'OP.GG',
  'Podcast',
  'TCGplayer',
  'TikTok',
  'Twitch',
  'Twitter (X)',
  'YouTube',
]);
export const enum_users_role = pgEnum('enum_users_role', [
  'admin',
  'creator',
  'user',
]);

export const articles = pgTable(
  'articles',
  {
    id: serial('id').primaryKey(),
    title: varchar('title'),
    author: integer('author_id').references(() => users.id, {
      onDelete: 'set null',
    }),
    slug: varchar('slug'),
    publishedAt: timestamp('published_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    coverImage: integer('cover_image_id').references(() => media.id, {
      onDelete: 'set null',
    }),
    excerpt: varchar('excerpt'),
    content: jsonb('content'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    _status: enum_articles_status('_status').default('draft'),
  },
  (columns) => ({
    articles_author_idx: index('articles_author_idx').on(columns.author),
    articles_slug_idx: uniqueIndex('articles_slug_idx').on(columns.slug),
    articles_cover_image_idx: index('articles_cover_image_idx').on(
      columns.coverImage
    ),
    articles_updated_at_idx: index('articles_updated_at_idx').on(
      columns.updatedAt
    ),
    articles_created_at_idx: index('articles_created_at_idx').on(
      columns.createdAt
    ),
    articles__status_idx: index('articles__status_idx').on(columns._status),
  })
);

export const articles_rels = pgTable(
  'articles_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    categoriesID: integer('categories_id'),
  },
  (columns) => ({
    order: index('articles_rels_order_idx').on(columns.order),
    parentIdx: index('articles_rels_parent_idx').on(columns.parent),
    pathIdx: index('articles_rels_path_idx').on(columns.path),
    articles_rels_categories_id_idx: index(
      'articles_rels_categories_id_idx'
    ).on(columns.categoriesID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [articles.id],
      name: 'articles_rels_parent_fk',
    }).onDelete('cascade'),
    categoriesIdFk: foreignKey({
      columns: [columns['categoriesID']],
      foreignColumns: [categories.id],
      name: 'articles_rels_categories_fk',
    }).onDelete('cascade'),
  })
);

export const _articles_v = pgTable(
  '_articles_v',
  {
    id: serial('id').primaryKey(),
    parent: integer('parent_id').references(() => articles.id, {
      onDelete: 'set null',
    }),
    version_title: varchar('version_title'),
    version_author: integer('version_author_id').references(() => users.id, {
      onDelete: 'set null',
    }),
    version_slug: varchar('version_slug'),
    version_publishedAt: timestamp('version_published_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    version_coverImage: integer('version_cover_image_id').references(
      () => media.id,
      {
        onDelete: 'set null',
      }
    ),
    version_excerpt: varchar('version_excerpt'),
    version_content: jsonb('version_content'),
    version_updatedAt: timestamp('version_updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    version_createdAt: timestamp('version_created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    version__status:
      enum__articles_v_version_status('version__status').default('draft'),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    latest: boolean('latest'),
    autosave: boolean('autosave'),
  },
  (columns) => ({
    _articles_v_parent_idx: index('_articles_v_parent_idx').on(columns.parent),
    _articles_v_version_version_author_idx: index(
      '_articles_v_version_version_author_idx'
    ).on(columns.version_author),
    _articles_v_version_version_slug_idx: index(
      '_articles_v_version_version_slug_idx'
    ).on(columns.version_slug),
    _articles_v_version_version_cover_image_idx: index(
      '_articles_v_version_version_cover_image_idx'
    ).on(columns.version_coverImage),
    _articles_v_version_version_updated_at_idx: index(
      '_articles_v_version_version_updated_at_idx'
    ).on(columns.version_updatedAt),
    _articles_v_version_version_created_at_idx: index(
      '_articles_v_version_version_created_at_idx'
    ).on(columns.version_createdAt),
    _articles_v_version_version__status_idx: index(
      '_articles_v_version_version__status_idx'
    ).on(columns.version__status),
    _articles_v_created_at_idx: index('_articles_v_created_at_idx').on(
      columns.createdAt
    ),
    _articles_v_updated_at_idx: index('_articles_v_updated_at_idx').on(
      columns.updatedAt
    ),
    _articles_v_latest_idx: index('_articles_v_latest_idx').on(columns.latest),
    _articles_v_autosave_idx: index('_articles_v_autosave_idx').on(
      columns.autosave
    ),
  })
);

export const _articles_v_rels = pgTable(
  '_articles_v_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    categoriesID: integer('categories_id'),
  },
  (columns) => ({
    order: index('_articles_v_rels_order_idx').on(columns.order),
    parentIdx: index('_articles_v_rels_parent_idx').on(columns.parent),
    pathIdx: index('_articles_v_rels_path_idx').on(columns.path),
    _articles_v_rels_categories_id_idx: index(
      '_articles_v_rels_categories_id_idx'
    ).on(columns.categoriesID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [_articles_v.id],
      name: '_articles_v_rels_parent_fk',
    }).onDelete('cascade'),
    categoriesIdFk: foreignKey({
      columns: [columns['categoriesID']],
      foreignColumns: [categories.id],
      name: '_articles_v_rels_categories_fk',
    }).onDelete('cascade'),
  })
);

export const artists = pgTable(
  'artists',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    artists_updated_at_idx: index('artists_updated_at_idx').on(
      columns.updatedAt
    ),
    artists_created_at_idx: index('artists_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const cards_recycle = pgTable(
  'cards_recycle',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    rune: enum_cards_recycle_rune('rune'),
  },
  (columns) => ({
    _orderIdx: index('cards_recycle_order_idx').on(columns._order),
    _parentIDIdx: index('cards_recycle_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [cards.id],
      name: 'cards_recycle_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const cards_rune = pgTable(
  'cards_rune',
  {
    order: integer('order').notNull(),
    parent: integer('parent_id').notNull(),
    value: enum_cards_rune('value'),
    id: serial('id').primaryKey(),
  },
  (columns) => ({
    orderIdx: index('cards_rune_order_idx').on(columns.order),
    parentIdx: index('cards_rune_parent_idx').on(columns.parent),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [cards.id],
      name: 'cards_rune_parent_fk',
    }).onDelete('cascade'),
  })
);

export const cards = pgTable(
  'cards',
  {
    id: serial('id').primaryKey(),
    full_card_name: varchar('full_card_name'),
    cost: numeric('cost'),
    type: enum_cards_type('type').notNull(),
    name: varchar('name').notNull(),
    subtitle: varchar('subtitle'),
    character: integer('character_id').references(() => characters.id, {
      onDelete: 'set null',
    }),
    might: numeric('might'),
    set_index: numeric('set_index').notNull(),
    set: integer('set_id')
      .notNull()
      .references(() => sets.id, {
        onDelete: 'set null',
      }),
    rarity: enum_cards_rarity('rarity').notNull(),
    artist: integer('artist_id').references(() => artists.id, {
      onDelete: 'set null',
    }),
    card_art: integer('card_art_id').references(() => media.id, {
      onDelete: 'set null',
    }),
    abilities: jsonb('abilities'),
    abilities_text: varchar('abilities_text'),
    flavor: jsonb('flavor'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    cards_character_idx: index('cards_character_idx').on(columns.character),
    cards_set_idx: index('cards_set_idx').on(columns.set),
    cards_artist_idx: index('cards_artist_idx').on(columns.artist),
    cards_card_art_idx: index('cards_card_art_idx').on(columns.card_art),
    cards_updated_at_idx: index('cards_updated_at_idx').on(columns.updatedAt),
    cards_created_at_idx: index('cards_created_at_idx').on(columns.createdAt),
  })
);

export const cards_rels = pgTable(
  'cards_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    keywordsID: integer('keywords_id'),
    tagsID: integer('tags_id'),
  },
  (columns) => ({
    order: index('cards_rels_order_idx').on(columns.order),
    parentIdx: index('cards_rels_parent_idx').on(columns.parent),
    pathIdx: index('cards_rels_path_idx').on(columns.path),
    cards_rels_keywords_id_idx: index('cards_rels_keywords_id_idx').on(
      columns.keywordsID
    ),
    cards_rels_tags_id_idx: index('cards_rels_tags_id_idx').on(columns.tagsID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [cards.id],
      name: 'cards_rels_parent_fk',
    }).onDelete('cascade'),
    keywordsIdFk: foreignKey({
      columns: [columns['keywordsID']],
      foreignColumns: [keywords.id],
      name: 'cards_rels_keywords_fk',
    }).onDelete('cascade'),
    tagsIdFk: foreignKey({
      columns: [columns['tagsID']],
      foreignColumns: [tags.id],
      name: 'cards_rels_tags_fk',
    }).onDelete('cascade'),
  })
);

export const categories = pgTable(
  'categories',
  {
    id: serial('id').primaryKey(),
    title: varchar('title').notNull(),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    categories_updated_at_idx: index('categories_updated_at_idx').on(
      columns.updatedAt
    ),
    categories_created_at_idx: index('categories_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const characters = pgTable(
  'characters',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    characters_updated_at_idx: index('characters_updated_at_idx').on(
      columns.updatedAt
    ),
    characters_created_at_idx: index('characters_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const keywords = pgTable(
  'keywords',
  {
    id: serial('id').primaryKey(),
    keyword: varchar('keyword'),
    type: enum_keywords_type('type'),
    position: enum_keywords_position('position').default('prefix'),
    color: enum_keywords_color('color'),
    reminder_text: jsonb('reminder_text'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    keywords_updated_at_idx: index('keywords_updated_at_idx').on(
      columns.updatedAt
    ),
    keywords_created_at_idx: index('keywords_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const media = pgTable(
  'media',
  {
    id: serial('id').primaryKey(),
    alt: varchar('alt').notNull(),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    url: varchar('url'),
    thumbnailURL: varchar('thumbnail_u_r_l'),
    filename: varchar('filename'),
    mimeType: varchar('mime_type'),
    filesize: numeric('filesize'),
    width: numeric('width'),
    height: numeric('height'),
    focalX: numeric('focal_x'),
    focalY: numeric('focal_y'),
  },
  (columns) => ({
    media_updated_at_idx: index('media_updated_at_idx').on(columns.updatedAt),
    media_created_at_idx: index('media_created_at_idx').on(columns.createdAt),
    media_filename_idx: uniqueIndex('media_filename_idx').on(columns.filename),
  })
);

export const sets = pgTable(
  'sets',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    releasedAt: timestamp('released_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    set_code: varchar('set_code'),
    total: numeric('total'),
    collectible: numeric('collectible'),
    key_art: integer('key_art_id').references(() => media.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    sets_key_art_idx: index('sets_key_art_idx').on(columns.key_art),
    sets_updated_at_idx: index('sets_updated_at_idx').on(columns.updatedAt),
    sets_created_at_idx: index('sets_created_at_idx').on(columns.createdAt),
  })
);

export const spoilers_rune = pgTable(
  'spoilers_rune',
  {
    order: integer('order').notNull(),
    parent: integer('parent_id').notNull(),
    value: enum_spoilers_rune('value'),
    id: serial('id').primaryKey(),
  },
  (columns) => ({
    orderIdx: index('spoilers_rune_order_idx').on(columns.order),
    parentIdx: index('spoilers_rune_parent_idx').on(columns.parent),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [spoilers.id],
      name: 'spoilers_rune_parent_fk',
    }).onDelete('cascade'),
  })
);

export const spoilers_recycle = pgTable(
  'spoilers_recycle',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    rune: enum_spoilers_recycle_rune('rune'),
  },
  (columns) => ({
    _orderIdx: index('spoilers_recycle_order_idx').on(columns._order),
    _parentIDIdx: index('spoilers_recycle_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [spoilers.id],
      name: 'spoilers_recycle_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const spoilers = pgTable(
  'spoilers',
  {
    id: serial('id').primaryKey(),
    title: varchar('title').notNull(),
    description: varchar('description'),
    source_url: varchar('source_url').notNull(),
    source_description: varchar('source_description').notNull(),
    type: enum_spoilers_type('type'),
    name: varchar('name'),
    subtitle: varchar('subtitle'),
    character: integer('character_id').references(() => characters.id, {
      onDelete: 'set null',
    }),
    might: numeric('might'),
    cost: numeric('cost'),
    card: integer('card_id').references(() => cards.id, {
      onDelete: 'set null',
    }),
    set_index: numeric('set_index'),
    set: integer('set_id').references(() => sets.id, {
      onDelete: 'set null',
    }),
    rarity: enum_spoilers_rarity('rarity'),
    artist: integer('artist_id').references(() => artists.id, {
      onDelete: 'set null',
    }),
    card_art: integer('card_art_id').references(() => media.id, {
      onDelete: 'set null',
    }),
    abilities: jsonb('abilities'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    spoilers_character_idx: index('spoilers_character_idx').on(
      columns.character
    ),
    spoilers_card_idx: index('spoilers_card_idx').on(columns.card),
    spoilers_set_idx: index('spoilers_set_idx').on(columns.set),
    spoilers_artist_idx: index('spoilers_artist_idx').on(columns.artist),
    spoilers_card_art_idx: index('spoilers_card_art_idx').on(columns.card_art),
    spoilers_updated_at_idx: index('spoilers_updated_at_idx').on(
      columns.updatedAt
    ),
    spoilers_created_at_idx: index('spoilers_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const spoilers_rels = pgTable(
  'spoilers_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    keywordsID: integer('keywords_id'),
    tagsID: integer('tags_id'),
  },
  (columns) => ({
    order: index('spoilers_rels_order_idx').on(columns.order),
    parentIdx: index('spoilers_rels_parent_idx').on(columns.parent),
    pathIdx: index('spoilers_rels_path_idx').on(columns.path),
    spoilers_rels_keywords_id_idx: index('spoilers_rels_keywords_id_idx').on(
      columns.keywordsID
    ),
    spoilers_rels_tags_id_idx: index('spoilers_rels_tags_id_idx').on(
      columns.tagsID
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [spoilers.id],
      name: 'spoilers_rels_parent_fk',
    }).onDelete('cascade'),
    keywordsIdFk: foreignKey({
      columns: [columns['keywordsID']],
      foreignColumns: [keywords.id],
      name: 'spoilers_rels_keywords_fk',
    }).onDelete('cascade'),
    tagsIdFk: foreignKey({
      columns: [columns['tagsID']],
      foreignColumns: [tags.id],
      name: 'spoilers_rels_tags_fk',
    }).onDelete('cascade'),
  })
);

export const tags = pgTable(
  'tags',
  {
    id: serial('id').primaryKey(),
    region: boolean('region').default(false),
    tag: varchar('tag'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    tags_updated_at_idx: index('tags_updated_at_idx').on(columns.updatedAt),
    tags_created_at_idx: index('tags_created_at_idx').on(columns.createdAt),
  })
);

export const users_links = pgTable(
  'users_links',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    site: enum_users_links_site('site').notNull(),
    url: varchar('url').notNull(),
  },
  (columns) => ({
    _orderIdx: index('users_links_order_idx').on(columns._order),
    _parentIDIdx: index('users_links_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [users.id],
      name: 'users_links_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const users = pgTable(
  'users',
  {
    id: serial('id').primaryKey(),
    email: varchar('email'),
    username: varchar('username'),
    clerk_id: varchar('clerk_id'),
    role: enum_users_role('role'),
    author_name: varchar('author_name'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    users_updated_at_idx: index('users_updated_at_idx').on(columns.updatedAt),
    users_created_at_idx: index('users_created_at_idx').on(columns.createdAt),
  })
);

export const decks_highlights = pgTable(
  'decks_highlights',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    highlight: integer('highlight_id').references(() => cards.id, {
      onDelete: 'set null',
    }),
  },
  (columns) => ({
    _orderIdx: index('decks_highlights_order_idx').on(columns._order),
    _parentIDIdx: index('decks_highlights_parent_id_idx').on(columns._parentID),
    decks_highlights_highlight_idx: index('decks_highlights_highlight_idx').on(
      columns.highlight
    ),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [decks.id],
      name: 'decks_highlights_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const decks_cardlist = pgTable(
  'decks_cardlist',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    card: integer('card_id').references(() => cards.id, {
      onDelete: 'set null',
    }),
    quantity: numeric('quantity'),
  },
  (columns) => ({
    _orderIdx: index('decks_cardlist_order_idx').on(columns._order),
    _parentIDIdx: index('decks_cardlist_parent_id_idx').on(columns._parentID),
    decks_cardlist_card_idx: index('decks_cardlist_card_idx').on(columns.card),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [decks.id],
      name: 'decks_cardlist_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const decks = pgTable(
  'decks',
  {
    id: serial('id').primaryKey(),
    author: integer('author_id')
      .notNull()
      .references(() => users.id, {
        onDelete: 'set null',
      }),
    name: varchar('name').notNull(),
    slug: varchar('slug'),
    public: boolean('public').default(false),
    guide: jsonb('guide'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    decks_author_idx: index('decks_author_idx').on(columns.author),
    decks_slug_idx: uniqueIndex('decks_slug_idx').on(columns.slug),
    decks_updated_at_idx: index('decks_updated_at_idx').on(columns.updatedAt),
    decks_created_at_idx: index('decks_created_at_idx').on(columns.createdAt),
  })
);

export const decks_rels = pgTable(
  'decks_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    tagsID: integer('tags_id'),
  },
  (columns) => ({
    order: index('decks_rels_order_idx').on(columns.order),
    parentIdx: index('decks_rels_parent_idx').on(columns.parent),
    pathIdx: index('decks_rels_path_idx').on(columns.path),
    decks_rels_tags_id_idx: index('decks_rels_tags_id_idx').on(columns.tagsID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [decks.id],
      name: 'decks_rels_parent_fk',
    }).onDelete('cascade'),
    tagsIdFk: foreignKey({
      columns: [columns['tagsID']],
      foreignColumns: [tags.id],
      name: 'decks_rels_tags_fk',
    }).onDelete('cascade'),
  })
);

export const card_collection_sets_cards = pgTable(
  'card_collection_sets_cards',
  {
    _order: integer('_order').notNull(),
    _parentID: varchar('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    card: integer('card_id').references(() => cards.id, {
      onDelete: 'set null',
    }),
    normal: numeric('normal').default('0'),
    foil: numeric('foil').default('0'),
  },
  (columns) => ({
    _orderIdx: index('card_collection_sets_cards_order_idx').on(columns._order),
    _parentIDIdx: index('card_collection_sets_cards_parent_id_idx').on(
      columns._parentID
    ),
    card_collection_sets_cards_card_idx: index(
      'card_collection_sets_cards_card_idx'
    ).on(columns.card),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [card_collection_sets.id],
      name: 'card_collection_sets_cards_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const card_collection_sets = pgTable(
  'card_collection_sets',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    set: integer('set_id').references(() => sets.id, {
      onDelete: 'set null',
    }),
    completion: varchar('completion').default('Not Started'),
  },
  (columns) => ({
    _orderIdx: index('card_collection_sets_order_idx').on(columns._order),
    _parentIDIdx: index('card_collection_sets_parent_id_idx').on(
      columns._parentID
    ),
    card_collection_sets_set_idx: index('card_collection_sets_set_idx').on(
      columns.set
    ),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [card_collection.id],
      name: 'card_collection_sets_parent_id_fk',
    }).onDelete('cascade'),
  })
);

export const card_collection = pgTable(
  'card_collection',
  {
    id: serial('id').primaryKey(),
    owner: integer('owner_id')
      .notNull()
      .references(() => users.id, {
        onDelete: 'set null',
      }),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    card_collection_owner_idx: index('card_collection_owner_idx').on(
      columns.owner
    ),
    card_collection_updated_at_idx: index('card_collection_updated_at_idx').on(
      columns.updatedAt
    ),
    card_collection_created_at_idx: index('card_collection_created_at_idx').on(
      columns.createdAt
    ),
  })
);

export const payload_locked_documents = pgTable(
  'payload_locked_documents',
  {
    id: serial('id').primaryKey(),
    globalSlug: varchar('global_slug'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_locked_documents_global_slug_idx: index(
      'payload_locked_documents_global_slug_idx'
    ).on(columns.globalSlug),
    payload_locked_documents_updated_at_idx: index(
      'payload_locked_documents_updated_at_idx'
    ).on(columns.updatedAt),
    payload_locked_documents_created_at_idx: index(
      'payload_locked_documents_created_at_idx'
    ).on(columns.createdAt),
  })
);

export const payload_locked_documents_rels = pgTable(
  'payload_locked_documents_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    articlesID: integer('articles_id'),
    artistsID: integer('artists_id'),
    cardsID: integer('cards_id'),
    categoriesID: integer('categories_id'),
    charactersID: integer('characters_id'),
    keywordsID: integer('keywords_id'),
    mediaID: integer('media_id'),
    setsID: integer('sets_id'),
    spoilersID: integer('spoilers_id'),
    tagsID: integer('tags_id'),
    usersID: integer('users_id'),
    decksID: integer('decks_id'),
    'card-collectionID': integer('card_collection_id'),
  },
  (columns) => ({
    order: index('payload_locked_documents_rels_order_idx').on(columns.order),
    parentIdx: index('payload_locked_documents_rels_parent_idx').on(
      columns.parent
    ),
    pathIdx: index('payload_locked_documents_rels_path_idx').on(columns.path),
    payload_locked_documents_rels_articles_id_idx: index(
      'payload_locked_documents_rels_articles_id_idx'
    ).on(columns.articlesID),
    payload_locked_documents_rels_artists_id_idx: index(
      'payload_locked_documents_rels_artists_id_idx'
    ).on(columns.artistsID),
    payload_locked_documents_rels_cards_id_idx: index(
      'payload_locked_documents_rels_cards_id_idx'
    ).on(columns.cardsID),
    payload_locked_documents_rels_categories_id_idx: index(
      'payload_locked_documents_rels_categories_id_idx'
    ).on(columns.categoriesID),
    payload_locked_documents_rels_characters_id_idx: index(
      'payload_locked_documents_rels_characters_id_idx'
    ).on(columns.charactersID),
    payload_locked_documents_rels_keywords_id_idx: index(
      'payload_locked_documents_rels_keywords_id_idx'
    ).on(columns.keywordsID),
    payload_locked_documents_rels_media_id_idx: index(
      'payload_locked_documents_rels_media_id_idx'
    ).on(columns.mediaID),
    payload_locked_documents_rels_sets_id_idx: index(
      'payload_locked_documents_rels_sets_id_idx'
    ).on(columns.setsID),
    payload_locked_documents_rels_spoilers_id_idx: index(
      'payload_locked_documents_rels_spoilers_id_idx'
    ).on(columns.spoilersID),
    payload_locked_documents_rels_tags_id_idx: index(
      'payload_locked_documents_rels_tags_id_idx'
    ).on(columns.tagsID),
    payload_locked_documents_rels_users_id_idx: index(
      'payload_locked_documents_rels_users_id_idx'
    ).on(columns.usersID),
    payload_locked_documents_rels_decks_id_idx: index(
      'payload_locked_documents_rels_decks_id_idx'
    ).on(columns.decksID),
    payload_locked_documents_rels_card_collection_id_idx: index(
      'payload_locked_documents_rels_card_collection_id_idx'
    ).on(columns['card-collectionID']),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_locked_documents.id],
      name: 'payload_locked_documents_rels_parent_fk',
    }).onDelete('cascade'),
    articlesIdFk: foreignKey({
      columns: [columns['articlesID']],
      foreignColumns: [articles.id],
      name: 'payload_locked_documents_rels_articles_fk',
    }).onDelete('cascade'),
    artistsIdFk: foreignKey({
      columns: [columns['artistsID']],
      foreignColumns: [artists.id],
      name: 'payload_locked_documents_rels_artists_fk',
    }).onDelete('cascade'),
    cardsIdFk: foreignKey({
      columns: [columns['cardsID']],
      foreignColumns: [cards.id],
      name: 'payload_locked_documents_rels_cards_fk',
    }).onDelete('cascade'),
    categoriesIdFk: foreignKey({
      columns: [columns['categoriesID']],
      foreignColumns: [categories.id],
      name: 'payload_locked_documents_rels_categories_fk',
    }).onDelete('cascade'),
    charactersIdFk: foreignKey({
      columns: [columns['charactersID']],
      foreignColumns: [characters.id],
      name: 'payload_locked_documents_rels_characters_fk',
    }).onDelete('cascade'),
    keywordsIdFk: foreignKey({
      columns: [columns['keywordsID']],
      foreignColumns: [keywords.id],
      name: 'payload_locked_documents_rels_keywords_fk',
    }).onDelete('cascade'),
    mediaIdFk: foreignKey({
      columns: [columns['mediaID']],
      foreignColumns: [media.id],
      name: 'payload_locked_documents_rels_media_fk',
    }).onDelete('cascade'),
    setsIdFk: foreignKey({
      columns: [columns['setsID']],
      foreignColumns: [sets.id],
      name: 'payload_locked_documents_rels_sets_fk',
    }).onDelete('cascade'),
    spoilersIdFk: foreignKey({
      columns: [columns['spoilersID']],
      foreignColumns: [spoilers.id],
      name: 'payload_locked_documents_rels_spoilers_fk',
    }).onDelete('cascade'),
    tagsIdFk: foreignKey({
      columns: [columns['tagsID']],
      foreignColumns: [tags.id],
      name: 'payload_locked_documents_rels_tags_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_locked_documents_rels_users_fk',
    }).onDelete('cascade'),
    decksIdFk: foreignKey({
      columns: [columns['decksID']],
      foreignColumns: [decks.id],
      name: 'payload_locked_documents_rels_decks_fk',
    }).onDelete('cascade'),
    'card-collectionIdFk': foreignKey({
      columns: [columns['card-collectionID']],
      foreignColumns: [card_collection.id],
      name: 'payload_locked_documents_rels_card_collection_fk',
    }).onDelete('cascade'),
  })
);

export const payload_preferences = pgTable(
  'payload_preferences',
  {
    id: serial('id').primaryKey(),
    key: varchar('key'),
    value: jsonb('value'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_preferences_key_idx: index('payload_preferences_key_idx').on(
      columns.key
    ),
    payload_preferences_updated_at_idx: index(
      'payload_preferences_updated_at_idx'
    ).on(columns.updatedAt),
    payload_preferences_created_at_idx: index(
      'payload_preferences_created_at_idx'
    ).on(columns.createdAt),
  })
);

export const payload_preferences_rels = pgTable(
  'payload_preferences_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    usersID: integer('users_id'),
  },
  (columns) => ({
    order: index('payload_preferences_rels_order_idx').on(columns.order),
    parentIdx: index('payload_preferences_rels_parent_idx').on(columns.parent),
    pathIdx: index('payload_preferences_rels_path_idx').on(columns.path),
    payload_preferences_rels_users_id_idx: index(
      'payload_preferences_rels_users_id_idx'
    ).on(columns.usersID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_preferences.id],
      name: 'payload_preferences_rels_parent_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_preferences_rels_users_fk',
    }).onDelete('cascade'),
  })
);

export const payload_migrations = pgTable(
  'payload_migrations',
  {
    id: serial('id').primaryKey(),
    name: varchar('name'),
    batch: numeric('batch'),
    updatedAt: timestamp('updated_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_migrations_updated_at_idx: index(
      'payload_migrations_updated_at_idx'
    ).on(columns.updatedAt),
    payload_migrations_created_at_idx: index(
      'payload_migrations_created_at_idx'
    ).on(columns.createdAt),
  })
);

export const relations_articles_rels = relations(articles_rels, ({ one }) => ({
  parent: one(articles, {
    fields: [articles_rels.parent],
    references: [articles.id],
    relationName: '_rels',
  }),
  categoriesID: one(categories, {
    fields: [articles_rels.categoriesID],
    references: [categories.id],
    relationName: 'categories',
  }),
}));
export const relations_articles = relations(articles, ({ one, many }) => ({
  author: one(users, {
    fields: [articles.author],
    references: [users.id],
    relationName: 'author',
  }),
  coverImage: one(media, {
    fields: [articles.coverImage],
    references: [media.id],
    relationName: 'coverImage',
  }),
  _rels: many(articles_rels, {
    relationName: '_rels',
  }),
}));
export const relations__articles_v_rels = relations(
  _articles_v_rels,
  ({ one }) => ({
    parent: one(_articles_v, {
      fields: [_articles_v_rels.parent],
      references: [_articles_v.id],
      relationName: '_rels',
    }),
    categoriesID: one(categories, {
      fields: [_articles_v_rels.categoriesID],
      references: [categories.id],
      relationName: 'categories',
    }),
  })
);
export const relations__articles_v = relations(
  _articles_v,
  ({ one, many }) => ({
    parent: one(articles, {
      fields: [_articles_v.parent],
      references: [articles.id],
      relationName: 'parent',
    }),
    version_author: one(users, {
      fields: [_articles_v.version_author],
      references: [users.id],
      relationName: 'version_author',
    }),
    version_coverImage: one(media, {
      fields: [_articles_v.version_coverImage],
      references: [media.id],
      relationName: 'version_coverImage',
    }),
    _rels: many(_articles_v_rels, {
      relationName: '_rels',
    }),
  })
);
export const relations_artists = relations(artists, () => ({}));
export const relations_cards_recycle = relations(cards_recycle, ({ one }) => ({
  _parentID: one(cards, {
    fields: [cards_recycle._parentID],
    references: [cards.id],
    relationName: 'recycle',
  }),
}));
export const relations_cards_rune = relations(cards_rune, ({ one }) => ({
  parent: one(cards, {
    fields: [cards_rune.parent],
    references: [cards.id],
    relationName: 'rune',
  }),
}));
export const relations_cards_rels = relations(cards_rels, ({ one }) => ({
  parent: one(cards, {
    fields: [cards_rels.parent],
    references: [cards.id],
    relationName: '_rels',
  }),
  keywordsID: one(keywords, {
    fields: [cards_rels.keywordsID],
    references: [keywords.id],
    relationName: 'keywords',
  }),
  tagsID: one(tags, {
    fields: [cards_rels.tagsID],
    references: [tags.id],
    relationName: 'tags',
  }),
}));
export const relations_cards = relations(cards, ({ one, many }) => ({
  recycle: many(cards_recycle, {
    relationName: 'recycle',
  }),
  rune: many(cards_rune, {
    relationName: 'rune',
  }),
  character: one(characters, {
    fields: [cards.character],
    references: [characters.id],
    relationName: 'character',
  }),
  set: one(sets, {
    fields: [cards.set],
    references: [sets.id],
    relationName: 'set',
  }),
  artist: one(artists, {
    fields: [cards.artist],
    references: [artists.id],
    relationName: 'artist',
  }),
  card_art: one(media, {
    fields: [cards.card_art],
    references: [media.id],
    relationName: 'card_art',
  }),
  _rels: many(cards_rels, {
    relationName: '_rels',
  }),
}));
export const relations_categories = relations(categories, () => ({}));
export const relations_characters = relations(characters, () => ({}));
export const relations_keywords = relations(keywords, () => ({}));
export const relations_media = relations(media, () => ({}));
export const relations_sets = relations(sets, ({ one }) => ({
  key_art: one(media, {
    fields: [sets.key_art],
    references: [media.id],
    relationName: 'key_art',
  }),
}));
export const relations_spoilers_rune = relations(spoilers_rune, ({ one }) => ({
  parent: one(spoilers, {
    fields: [spoilers_rune.parent],
    references: [spoilers.id],
    relationName: 'rune',
  }),
}));
export const relations_spoilers_recycle = relations(
  spoilers_recycle,
  ({ one }) => ({
    _parentID: one(spoilers, {
      fields: [spoilers_recycle._parentID],
      references: [spoilers.id],
      relationName: 'recycle',
    }),
  })
);
export const relations_spoilers_rels = relations(spoilers_rels, ({ one }) => ({
  parent: one(spoilers, {
    fields: [spoilers_rels.parent],
    references: [spoilers.id],
    relationName: '_rels',
  }),
  keywordsID: one(keywords, {
    fields: [spoilers_rels.keywordsID],
    references: [keywords.id],
    relationName: 'keywords',
  }),
  tagsID: one(tags, {
    fields: [spoilers_rels.tagsID],
    references: [tags.id],
    relationName: 'tags',
  }),
}));
export const relations_spoilers = relations(spoilers, ({ one, many }) => ({
  rune: many(spoilers_rune, {
    relationName: 'rune',
  }),
  character: one(characters, {
    fields: [spoilers.character],
    references: [characters.id],
    relationName: 'character',
  }),
  recycle: many(spoilers_recycle, {
    relationName: 'recycle',
  }),
  card: one(cards, {
    fields: [spoilers.card],
    references: [cards.id],
    relationName: 'card',
  }),
  set: one(sets, {
    fields: [spoilers.set],
    references: [sets.id],
    relationName: 'set',
  }),
  artist: one(artists, {
    fields: [spoilers.artist],
    references: [artists.id],
    relationName: 'artist',
  }),
  card_art: one(media, {
    fields: [spoilers.card_art],
    references: [media.id],
    relationName: 'card_art',
  }),
  _rels: many(spoilers_rels, {
    relationName: '_rels',
  }),
}));
export const relations_tags = relations(tags, () => ({}));
export const relations_users_links = relations(users_links, ({ one }) => ({
  _parentID: one(users, {
    fields: [users_links._parentID],
    references: [users.id],
    relationName: 'links',
  }),
}));
export const relations_users = relations(users, ({ many }) => ({
  links: many(users_links, {
    relationName: 'links',
  }),
}));
export const relations_decks_highlights = relations(
  decks_highlights,
  ({ one }) => ({
    _parentID: one(decks, {
      fields: [decks_highlights._parentID],
      references: [decks.id],
      relationName: 'highlights',
    }),
    highlight: one(cards, {
      fields: [decks_highlights.highlight],
      references: [cards.id],
      relationName: 'highlight',
    }),
  })
);
export const relations_decks_cardlist = relations(
  decks_cardlist,
  ({ one }) => ({
    _parentID: one(decks, {
      fields: [decks_cardlist._parentID],
      references: [decks.id],
      relationName: 'cardlist',
    }),
    card: one(cards, {
      fields: [decks_cardlist.card],
      references: [cards.id],
      relationName: 'card',
    }),
  })
);
export const relations_decks_rels = relations(decks_rels, ({ one }) => ({
  parent: one(decks, {
    fields: [decks_rels.parent],
    references: [decks.id],
    relationName: '_rels',
  }),
  tagsID: one(tags, {
    fields: [decks_rels.tagsID],
    references: [tags.id],
    relationName: 'tags',
  }),
}));
export const relations_decks = relations(decks, ({ one, many }) => ({
  author: one(users, {
    fields: [decks.author],
    references: [users.id],
    relationName: 'author',
  }),
  highlights: many(decks_highlights, {
    relationName: 'highlights',
  }),
  cardlist: many(decks_cardlist, {
    relationName: 'cardlist',
  }),
  _rels: many(decks_rels, {
    relationName: '_rels',
  }),
}));
export const relations_card_collection_sets_cards = relations(
  card_collection_sets_cards,
  ({ one }) => ({
    _parentID: one(card_collection_sets, {
      fields: [card_collection_sets_cards._parentID],
      references: [card_collection_sets.id],
      relationName: 'cards',
    }),
    card: one(cards, {
      fields: [card_collection_sets_cards.card],
      references: [cards.id],
      relationName: 'card',
    }),
  })
);
export const relations_card_collection_sets = relations(
  card_collection_sets,
  ({ one, many }) => ({
    _parentID: one(card_collection, {
      fields: [card_collection_sets._parentID],
      references: [card_collection.id],
      relationName: 'sets',
    }),
    set: one(sets, {
      fields: [card_collection_sets.set],
      references: [sets.id],
      relationName: 'set',
    }),
    cards: many(card_collection_sets_cards, {
      relationName: 'cards',
    }),
  })
);
export const relations_card_collection = relations(
  card_collection,
  ({ one, many }) => ({
    owner: one(users, {
      fields: [card_collection.owner],
      references: [users.id],
      relationName: 'owner',
    }),
    sets: many(card_collection_sets, {
      relationName: 'sets',
    }),
  })
);
export const relations_payload_locked_documents_rels = relations(
  payload_locked_documents_rels,
  ({ one }) => ({
    parent: one(payload_locked_documents, {
      fields: [payload_locked_documents_rels.parent],
      references: [payload_locked_documents.id],
      relationName: '_rels',
    }),
    articlesID: one(articles, {
      fields: [payload_locked_documents_rels.articlesID],
      references: [articles.id],
      relationName: 'articles',
    }),
    artistsID: one(artists, {
      fields: [payload_locked_documents_rels.artistsID],
      references: [artists.id],
      relationName: 'artists',
    }),
    cardsID: one(cards, {
      fields: [payload_locked_documents_rels.cardsID],
      references: [cards.id],
      relationName: 'cards',
    }),
    categoriesID: one(categories, {
      fields: [payload_locked_documents_rels.categoriesID],
      references: [categories.id],
      relationName: 'categories',
    }),
    charactersID: one(characters, {
      fields: [payload_locked_documents_rels.charactersID],
      references: [characters.id],
      relationName: 'characters',
    }),
    keywordsID: one(keywords, {
      fields: [payload_locked_documents_rels.keywordsID],
      references: [keywords.id],
      relationName: 'keywords',
    }),
    mediaID: one(media, {
      fields: [payload_locked_documents_rels.mediaID],
      references: [media.id],
      relationName: 'media',
    }),
    setsID: one(sets, {
      fields: [payload_locked_documents_rels.setsID],
      references: [sets.id],
      relationName: 'sets',
    }),
    spoilersID: one(spoilers, {
      fields: [payload_locked_documents_rels.spoilersID],
      references: [spoilers.id],
      relationName: 'spoilers',
    }),
    tagsID: one(tags, {
      fields: [payload_locked_documents_rels.tagsID],
      references: [tags.id],
      relationName: 'tags',
    }),
    usersID: one(users, {
      fields: [payload_locked_documents_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
    decksID: one(decks, {
      fields: [payload_locked_documents_rels.decksID],
      references: [decks.id],
      relationName: 'decks',
    }),
    'card-collectionID': one(card_collection, {
      fields: [payload_locked_documents_rels['card-collectionID']],
      references: [card_collection.id],
      relationName: 'card-collection',
    }),
  })
);
export const relations_payload_locked_documents = relations(
  payload_locked_documents,
  ({ many }) => ({
    _rels: many(payload_locked_documents_rels, {
      relationName: '_rels',
    }),
  })
);
export const relations_payload_preferences_rels = relations(
  payload_preferences_rels,
  ({ one }) => ({
    parent: one(payload_preferences, {
      fields: [payload_preferences_rels.parent],
      references: [payload_preferences.id],
      relationName: '_rels',
    }),
    usersID: one(users, {
      fields: [payload_preferences_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
  })
);
export const relations_payload_preferences = relations(
  payload_preferences,
  ({ many }) => ({
    _rels: many(payload_preferences_rels, {
      relationName: '_rels',
    }),
  })
);
export const relations_payload_migrations = relations(
  payload_migrations,
  () => ({})
);

type DatabaseSchema = {
  enum_articles_status: typeof enum_articles_status;
  enum__articles_v_version_status: typeof enum__articles_v_version_status;
  enum_cards_recycle_rune: typeof enum_cards_recycle_rune;
  enum_cards_rune: typeof enum_cards_rune;
  enum_cards_type: typeof enum_cards_type;
  enum_cards_rarity: typeof enum_cards_rarity;
  enum_keywords_type: typeof enum_keywords_type;
  enum_keywords_position: typeof enum_keywords_position;
  enum_keywords_color: typeof enum_keywords_color;
  enum_spoilers_rune: typeof enum_spoilers_rune;
  enum_spoilers_recycle_rune: typeof enum_spoilers_recycle_rune;
  enum_spoilers_type: typeof enum_spoilers_type;
  enum_spoilers_rarity: typeof enum_spoilers_rarity;
  enum_users_links_site: typeof enum_users_links_site;
  enum_users_role: typeof enum_users_role;
  articles: typeof articles;
  articles_rels: typeof articles_rels;
  _articles_v: typeof _articles_v;
  _articles_v_rels: typeof _articles_v_rels;
  artists: typeof artists;
  cards_recycle: typeof cards_recycle;
  cards_rune: typeof cards_rune;
  cards: typeof cards;
  cards_rels: typeof cards_rels;
  categories: typeof categories;
  characters: typeof characters;
  keywords: typeof keywords;
  media: typeof media;
  sets: typeof sets;
  spoilers_rune: typeof spoilers_rune;
  spoilers_recycle: typeof spoilers_recycle;
  spoilers: typeof spoilers;
  spoilers_rels: typeof spoilers_rels;
  tags: typeof tags;
  users_links: typeof users_links;
  users: typeof users;
  decks_highlights: typeof decks_highlights;
  decks_cardlist: typeof decks_cardlist;
  decks: typeof decks;
  decks_rels: typeof decks_rels;
  card_collection_sets_cards: typeof card_collection_sets_cards;
  card_collection_sets: typeof card_collection_sets;
  card_collection: typeof card_collection;
  payload_locked_documents: typeof payload_locked_documents;
  payload_locked_documents_rels: typeof payload_locked_documents_rels;
  payload_preferences: typeof payload_preferences;
  payload_preferences_rels: typeof payload_preferences_rels;
  payload_migrations: typeof payload_migrations;
  relations_articles_rels: typeof relations_articles_rels;
  relations_articles: typeof relations_articles;
  relations__articles_v_rels: typeof relations__articles_v_rels;
  relations__articles_v: typeof relations__articles_v;
  relations_artists: typeof relations_artists;
  relations_cards_recycle: typeof relations_cards_recycle;
  relations_cards_rune: typeof relations_cards_rune;
  relations_cards_rels: typeof relations_cards_rels;
  relations_cards: typeof relations_cards;
  relations_categories: typeof relations_categories;
  relations_characters: typeof relations_characters;
  relations_keywords: typeof relations_keywords;
  relations_media: typeof relations_media;
  relations_sets: typeof relations_sets;
  relations_spoilers_rune: typeof relations_spoilers_rune;
  relations_spoilers_recycle: typeof relations_spoilers_recycle;
  relations_spoilers_rels: typeof relations_spoilers_rels;
  relations_spoilers: typeof relations_spoilers;
  relations_tags: typeof relations_tags;
  relations_users_links: typeof relations_users_links;
  relations_users: typeof relations_users;
  relations_decks_highlights: typeof relations_decks_highlights;
  relations_decks_cardlist: typeof relations_decks_cardlist;
  relations_decks_rels: typeof relations_decks_rels;
  relations_decks: typeof relations_decks;
  relations_card_collection_sets_cards: typeof relations_card_collection_sets_cards;
  relations_card_collection_sets: typeof relations_card_collection_sets;
  relations_card_collection: typeof relations_card_collection;
  relations_payload_locked_documents_rels: typeof relations_payload_locked_documents_rels;
  relations_payload_locked_documents: typeof relations_payload_locked_documents;
  relations_payload_preferences_rels: typeof relations_payload_preferences_rels;
  relations_payload_preferences: typeof relations_payload_preferences;
  relations_payload_migrations: typeof relations_payload_migrations;
};

declare module '@payloadcms/db-postgres/types' {
  export interface GeneratedDatabaseSchema {
    schema: DatabaseSchema;
  }
}
